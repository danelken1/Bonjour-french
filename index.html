<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bonjour! â€” A Canvas French Lab</title>
<style>
  html, body { height:100%; margin:0; background:#0f1222; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; outline:none; }
</style>
</head>
<body>
<canvas id="app" aria-label="French learning app"></canvas>

<script>
/* ===========================================================
   Bonjour! â€” A Canvas French Lab (Fixed + Optimized)
   - Canvas-only UI
   - Activities: Home, Flashcards, Quiz, Mouse & Cheese
   - Daily progress via localStorage
   - TTS voice on cheese eat
   - Arrow keys in game
   - PERF: debounced resize, cached gradients, fewer allocs
   =========================================================== */

/* ------------------ Canvas & Context --------------------- */
const canvas = document.getElementById('app');
const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });

/* ------------------ Caches & Helpers (MOVED UP) ---------- */
const cache = {
  gradients: Object.create(null),
  fontsSet: false
};
function setFonts() {
  if (cache.fontsSet) return;
  cache.fontsSet = true;
  // Hint fonts early to reduce layout jank
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto';
}
setFonts();

function roundRectPath(c, x,y,w,h,r=16) {
  c.beginPath();
  c.moveTo(x+r, y);
  c.arcTo(x+w, y, x+w, y+h, r);
  c.arcTo(x+w, y+h, x, y+h, r);
  c.arcTo(x, y+h, x, y, r);
  c.arcTo(x, y, x+w, y, r);
  c.closePath();
}
function drawButton(x,y,w,h,label,opts={}) {
  const color = opts.color || '#FFD166';
  const stroke = opts.stroke || '#2D2A3E';
  ctx.save();
  roundRectPath(ctx, x,y,w,h,14);
  const key = `btn_${color}_${w}x${h}`;
  let grad = cache.gradients[key];
  if (!grad) {
    grad = ctx.createLinearGradient(x,y,x,y+h);
    grad.addColorStop(0, color);
    grad.addColorStop(1, shade(color, -15));
    cache.gradients[key] = grad;
  }
  ctx.fillStyle = grad; ctx.fill();
  ctx.lineWidth = 3; ctx.strokeStyle = stroke; ctx.stroke();

  ctx.fillStyle = '#2D2A3E';
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(0,0,0,0.15)'; ctx.shadowBlur = 6;
  const cx = x+w/2, cy = y+h/2;
  ctx.fillText(label, cx, cy);
  ctx.restore();
  return { x,y,w,h };
}
function isInside(rect, px,py) {
  return px>=rect.x && py>=rect.y && px<=rect.x+rect.w && py<=rect.y+rect.h;
}
function shade(hex, amt) {
  const col = hex.replace('#','');
  const num = parseInt(col,16);
  let r = Math.max(0, Math.min(255, (num>>16) + amt));
  let g = Math.max(0, Math.min(255, ((num>>8)&0xFF)+amt));
  let b = Math.max(0, Math.min(255, (num&0xFF)+amt));
  return '#'+(r<<16 | g<<8 | b).toString(16).padStart(6,'0');
}

/* ------------------ Globals & Resize --------------------- */
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
const UXW = 1280, UXH = 800;   // design-space
let VW = 0, VH = 0;            // device pixels backing the canvas
let SCALE = 1;                 // scale to fit UX within viewport
let OFFSET_X = 0, OFFSET_Y = 0;

let _resizeRAF = 0;
function doResize() {
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const w = Math.floor(window.innerWidth * DPR);
  const h = Math.floor(window.innerHeight * DPR);
  if (w === canvas.width && h === canvas.height) return;

  canvas.width = w;
  canvas.height = h;
  VW = canvas.width; VH = canvas.height;

  const scaleX = VW / UXW, scaleY = VH / UXH;
  SCALE = Math.min(scaleX, scaleY);
  OFFSET_X = (VW / SCALE - UXW) / 2;
  OFFSET_Y = (VH / SCALE - UXH) / 2;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(SCALE, SCALE);
  ctx.translate(OFFSET_X, OFFSET_Y);

  // Invalidate cached gradients that depend on size
  cache.gradients = {};
}
function queueResize() {
  if (_resizeRAF) return;
  _resizeRAF = requestAnimationFrame(() => { _resizeRAF = 0; doResize(); });
}
window.addEventListener('resize', queueResize, { passive: true });
doResize();

/* ------------------ Pointer + Keys ----------------------- */
const pointer = { x:0, y:0, down:false, justReleased:false };
function toUX(clientX, clientY) {
  // Convert CSS px to UX coordinates (inverse of our transform)
  const dpr = DPR;
  const scaleX = (canvas.width) / UXW, scaleY = (canvas.height) / UXH;
  const s = Math.min(scaleX, scaleY);
  const offX = (canvas.width/s - UXW) / 2;
  const offY = (canvas.height/s - UXH) / 2;
  return { x: (clientX*dpr)/s - offX, y: (clientY*dpr)/s - offY };
}
canvas.addEventListener('pointerdown', e=>{
  const p = toUX(e.clientX, e.clientY);
  pointer.x = p.x; pointer.y = p.y; pointer.down = true;
});
canvas.addEventListener('pointermove', e=>{
  const p = toUX(e.clientX, e.clientY);
  pointer.x = p.x; pointer.y = p.y;
});
canvas.addEventListener('pointerup', e=>{
  const p = toUX(e.clientX, e.clientY);
  pointer.x = p.x; pointer.y = p.y;
  pointer.down = false; pointer.justReleased = true;
  unlockAudio();
}, { passive:true });

window.addEventListener('keydown', (e)=>{
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  unlockAudio();
});

/* ------------------ Theme / Background ------------------- */
const skyline = {
  drawBackdrop(t) {
    // Cached vertical gradient
    const key = 'bg_grad';
    let g = cache.gradients[key];
    if (!g) {
      g = ctx.createLinearGradient(0,0,0,UXH);
      g.addColorStop(0, '#1c2040');
      g.addColorStop(0.45, '#2b2e5e');
      g.addColorStop(1, '#3f2b4f');
      cache.gradients[key] = g;
    }
    ctx.fillStyle = g;
    ctx.fillRect(0,0,UXW,UXH);

    // Light bokeh
    for (let i=0;i<24;i++) {
      const x = (i*137 + (t*0.02*i)%UXW) % UXW;
      const y = (i*97 + (t*0.015*i)%UXH) % UXH;
      const r = (i%5)+2;
      ctx.globalAlpha = 0.08 + 0.05*Math.sin((t*0.001*i));
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = '#FFD166'; ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Eiffel silhouette
    ctx.save();
    ctx.translate(UXW*0.8, UXH*0.7);
    ctx.scale(1.2,1.2);
    ctx.fillStyle = '#141326';
    ctx.beginPath();
    ctx.moveTo(-20,0); ctx.lineTo(20,0); ctx.lineTo(0,-160); ctx.closePath(); ctx.fill();
    ctx.fillRect(-6,-160,12,12);
    ctx.fillRect(-4,-172,8,8);
    ctx.lineWidth = 3; ctx.strokeStyle = '#191832';
    for (let y=-10; y>-160; y-=25) {
      ctx.beginPath(); ctx.moveTo(-20-(y/8), y); ctx.lineTo(20+(y/8), y); ctx.stroke();
    }
    ctx.restore();
  }
};

/* ------------------ Confetti ----------------------------- */
const confetti = [];
function spawnConfetti(x,y, n=18) {
  for (let i=0;i<n;i++) {
    confetti.push({
      x, y,
      vx: (Math.random()*2-1)*4.5,
      vy: -Math.random()*6-3,
      g: 0.22,
      life: 54+Math.random()*30,
      color: ['#FFD166','#06D6A0','#EF476F','#118AB2'][Math.floor(Math.random()*4)]
    });
  }
}
function stepConfetti() {
  for (let i=confetti.length-1;i>=0;i--) {
    const p = confetti[i];
    p.vx *= 0.995; p.vy += p.g;
    p.x += p.vx; p.y += p.vy;
    if (--p.life <= 0) confetti.splice(i,1);
  }
}
function drawConfetti() {
  ctx.save();
  for (let i=0;i<confetti.length;i++) {
    const p = confetti[i];
    ctx.globalAlpha = Math.max(0, Math.min(1, p.life/90));
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
  ctx.globalAlpha = 1;
}

/* ------------------ Data: Words -------------------------- */
const WORDS = [
  { fr:'bonjour', en:'hello' },
  { fr:'au revoir', en:'goodbye' },
  { fr:'sâ€™il vous plaÃ®t', en:'please' },
  { fr:'merci', en:'thank you' },
  { fr:'de rien', en:'youâ€™re welcome' },
  { fr:'oui', en:'yes' },
  { fr:'non', en:'no' },
  { fr:'pardon', en:'sorry / excuse me' },
  { fr:'comment Ã§a va ?', en:'how are you?' },
  { fr:'trÃ¨s bien', en:'very well' },
  { fr:'je mâ€™appelle', en:'my name is' },
  { fr:'enchantÃ©(e)', en:'nice to meet you' },
  { fr:'oÃ¹', en:'where' },
  { fr:'quand', en:'when' },
  { fr:'pourquoi', en:'why' },
  { fr:'qui', en:'who' },
  { fr:'combien', en:'how much / how many' },
  { fr:'je voudrais', en:'I would like' },
  { fr:'lâ€™addition', en:'the bill/check' },
  { fr:'eau', en:'water' },
  { fr:'pain', en:'bread' },
  { fr:'fromage', en:'cheese' },
  { fr:'cafÃ©', en:'coffee' },
  { fr:'thÃ©', en:'tea' },
  { fr:'lait', en:'milk' },
  { fr:'le matin', en:'the morning' },
  { fr:'le soir', en:'the evening' },
  { fr:'aujourdâ€™hui', en:'today' },
  { fr:'demain', en:'tomorrow' },
  { fr:'hier', en:'yesterday' },
  { fr:'gauche', en:'left' },
  { fr:'droite', en:'right' },
  { fr:'tout droit', en:'straight ahead' },
  { fr:'jâ€™ai faim', en:'Iâ€™m hungry' },
  { fr:'jâ€™ai soif', en:'Iâ€™m thirsty' },
  { fr:'je ne comprends pas', en:'I donâ€™t understand' },
  { fr:'parlez-vous anglais ?', en:'do you speak English?' },
  { fr:'Ã  bientÃ´t', en:'see you soon' },
  { fr:'bien sÃ»r', en:'of course' },
  { fr:'bon appÃ©tit', en:'enjoy your meal' },
  { fr:'fÃ©licitations', en:'congratulations' }
];

/* ------------------ TTS (SpeechSynthesis) ---------------- */
let voices = [];
let audioUnlocked = false;
function loadVoices() { voices = speechSynthesis.getVoices() || []; }
if ('speechSynthesis' in window) {
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;
}
function unlockAudio() {
  if (audioUnlocked) return;
  audioUnlocked = true;
  try { const u = new SpeechSynthesisUtterance(' '); speechSynthesis.speak(u); } catch {}
  try { getBeepContext(); } catch {}
}
function pickVoice(langPrefix) {
  if (!voices || !voices.length) return null;
  const prefer = voices.filter(v => v.lang && v.lang.toLowerCase().startsWith(langPrefix));
  return prefer.find(v => /female|Google FranÃ§ais|Amelie|Thomas|Audrey/i.test(v.name)) || prefer[0] || voices[0];
}
function speakWord(fr, en) {
  if (!('speechSynthesis' in window)) return;
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  const u1 = new SpeechSynthesisUtterance(fr);
  u1.lang = 'fr-FR'; u1.voice = pickVoice('fr'); u1.rate = 0.9; u1.pitch = 1.05; u1.volume = 1;
  const u2 = new SpeechSynthesisUtterance(`means: ${en}`);
  u2.lang = 'en-US'; u2.voice = pickVoice('en'); u2.rate = 1.0; u2.pitch = 1; u2.volume = 0.9;
  speechSynthesis.speak(u1); speechSynthesis.speak(u2);
}

/* ------------------ Tiny SFX (beep) ---------------------- */
let _beepCtx = null;
function getBeepContext() {
  if (_beepCtx) return _beepCtx;
  const AC = window.AudioContext || window.webkitAudioContext;
  _beepCtx = new AC({ latencyHint: 'interactive' });
  return _beepCtx;
}
function beep(freq=880, dur=0.08) {
  try {
    const ac = getBeepContext();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = 'triangle';
    o.frequency.value = freq;
    o.connect(g); g.connect(ac.destination);
    const now = ac.currentTime;
    g.gain.setValueAtTime(0.001, now);
    g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    o.start(now); o.stop(now + dur);
  } catch {}
}

/* ------------------ Progress & Streak -------------------- */
const STORAGE_KEY = 'bonjour_progress_v1';
function todayKey() {
  const d = new Date();
  const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
const defaultProgress = {
  daily: {}, // date -> {flashcards, quizCorrect, cheese, wordsLearned}
  totals: { flashcards:0, quizCorrect:0, cheese:0, wordsLearned:0 },
  lastOpen: null
};
let progress = (()=>{
  try { const raw = localStorage.getItem(STORAGE_KEY); if (raw) return JSON.parse(raw); } catch {}
  return JSON.parse(JSON.stringify(defaultProgress));
})();
function saveProgress() { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); } catch {} }
function bump(metric, val=1) {
  const key = todayKey();
  if (!progress.daily[key]) progress.daily[key] = {flashcards:0, quizCorrect:0, cheese:0, wordsLearned:0};
  progress.daily[key][metric] = (progress.daily[key][metric]||0) + val;
  progress.totals[metric] = (progress.totals[metric]||0) + val;
  saveProgress();
}
function getStreak(days=14) {
  const res = [];
  const d = new Date();
  for (let i=0;i<days;i++) {
    const dt = new Date(d.getFullYear(), d.getMonth(), d.getDate()-i);
    const key = dt.toISOString().slice(0,10);
    res.push({ date:key, active: !!progress.daily[key] && Object.values(progress.daily[key]).some(v=>v>0) });
  }
  let streak = 0;
  for (let i=0;i<res.length;i++) { if (res[i].active) streak++; else break; }
  return { streak, days: res.reverse() };
}

/* ------------------ Navigation & UI ---------------------- */
const Scenes = { HOME:'HOME', FLASH:'FLASH', QUIZ:'QUIZ', GAME:'GAME', PROGRESS:'PROGRESS' };
let scene = Scenes.HOME;

const ui = {
  buttons: [],
  add(rect, onClick) { this.buttons.push({rect,onClick}); },
  reset() { this.buttons.length = 0; },
  handlePointer() {
    if (!pointer.justReleased) return;
    pointer.justReleased = false;
    const {x,y} = pointer;
    const arr = this.buttons;
    for (let i=0;i<arr.length;i++) {
      const b = arr[i];
      if (isInside(b.rect, x,y)) { b.onClick(); return; }
    }
  }
};

/* ------------------ Flashcards --------------------------- */
let flashIndex = 0;
let flashFlipped = false;
let flashOrder = shuffle([...Array(WORDS.length).keys()]);
function shuffle(a) { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function nextFlash() { flashIndex = (flashIndex + 1) % flashOrder.length; flashFlipped = false; }

function drawFlashcards(t) {
  skyline.drawBackdrop(t);
  ui.reset();
  drawHeader('Flashcards', 'Tap to flip; â€œI knew itâ€ to advance', t);

  const i = flashOrder[flashIndex];
  const w = WORDS[i];
  const card = { x: UXW*0.5-250, y: UXH*0.45-170, w: 500, h: 340 };

  // Card
  ctx.save();
  roundRectPath(ctx, card.x, card.y, card.w, card.h, 22);
  let cg = cache.gradients['card'];
  if (!cg) {
    cg = ctx.createLinearGradient(card.x, card.y, card.x, card.y+card.h);
    cg.addColorStop(0, '#fff'); cg.addColorStop(1, '#f4f2ff');
    cache.gradients['card'] = cg;
  }
  ctx.fillStyle = cg; ctx.fill();
  ctx.lineWidth = 4; ctx.strokeStyle = '#2D2A3E'; ctx.stroke();

  ctx.fillStyle = '#2D2A3E'; ctx.textAlign = 'center';

  if (!flashFlipped) {
    ctx.font = '700 64px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(w.fr, card.x+card.w/2, card.y+card.h/2);
    ctx.font = '400 22px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText('(tap card to flip)', card.x+card.w/2, card.y+card.h*0.78);
  } else {
    ctx.font = '700 54px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(w.en, card.x+card.w/2, card.y+card.h/2);
    ctx.font = '400 24px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(`French: ${w.fr}`, card.x+card.w/2, card.y+card.h*0.72);
  }
  ctx.restore();

  // Interactions
  const flipRect = {x:card.x, y:card.y, w:card.w, h:card.h};
  ui.add(flipRect, ()=>{ flashFlipped = !flashFlipped; beep(660, 0.05); });

  const b1 = drawButton(UXW*0.5-250, card.y+card.h+30, 220, 56, 'Practice again', {color:'#B8B8FF'});
  const b2 = drawButton(UXW*0.5+30,  card.y+card.h+30, 220, 56, 'I knew it', {color:'#06D6A0'});
  ui.add(b1, ()=>{ spawnConfetti(b1.x+b1.w/2, b1.y); beep(500, 0.06); });
  ui.add(b2, ()=>{ spawnConfetti(b2.x+b2.w/2, b2.y); beep(900, 0.06); bump('flashcards',1); nextFlash(); });

  drawFooterNav();
}

/* ------------------ Quiz -------------------------------- */
let quizQ = makeQuizQ();
let quizFeedback = null;
let quizFeedbackT = 0;

function makeQuizQ() {
  const correctIdx = Math.floor(Math.random()*WORDS.length);
  const correct = WORDS[correctIdx];
  const choices = [correct];
  while (choices.length<4) {
    const r = WORDS[Math.floor(Math.random()*WORDS.length)];
    if (!choices.includes(r)) choices.push(r);
  }
  shuffle(choices);
  const mode = Math.random()<0.5 ? 'FR2EN' : 'EN2FR';
  return { mode, correct, choices, askedAt: performance.now() };
}

function drawQuiz(t) {
  skyline.drawBackdrop(t);
  ui.reset();
  drawHeader('Quick Quiz', 'Choose the correct translation', t);

  const q = quizQ;
  const prompt = (q.mode==='FR2EN') ? q.correct.fr : q.correct.en;
  const title = (q.mode==='FR2EN') ? 'What does this mean?' : 'How do you say this in French?';

  ctx.fillStyle = '#FFD166';
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'center';
  ctx.fillText(title, UXW*0.5, UXH*0.3-40);

  ctx.fillStyle = '#FFFFFF';
  ctx.font = '700 56px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.fillText(prompt, UXW*0.5, UXH*0.3+10);

  const baseY = UXH*0.45;
  for (let i=0;i<4;i++) {
    const c = q.choices[i];
    const label = (q.mode==='FR2EN') ? c.en : c.fr;
    const rect = drawButton(UXW*0.5-300, baseY + i*80, 600, 60, label, { color:'#B8F1F0' });
    ui.add(rect, ()=>{
      const correct = c === q.correct;
      if (correct) { spawnConfetti(rect.x+rect.w/2, rect.y); beep(1000, 0.08); bump('quizCorrect',1); }
      else { beep(220, 0.12); }
      quizFeedback = { correct, chosen: label, answer: (q.mode==='FR2EN') ? q.correct.en : q.correct.fr };
      quizFeedbackT = t;
      quizQ = makeQuizQ();
    });
  }

  if (quizFeedback) {
    const age = t - quizFeedbackT;
    if (age < 1500) {
      const a = 1 - Math.min(1, age/1500);
      drawToast(UXW*0.5, UXH*0.2, quizFeedback.correct ? 'Nice! ðŸŽ‰' : `Answer: ${quizFeedback.answer}`, quizFeedback.correct ? '#06D6A0' : '#EF476F', a);
    } else quizFeedback = null;
  }

  drawFooterNav();
}

function drawToast(cx, cy, text, color, alpha=1) {
  ctx.save();
  ctx.globalAlpha = 0.9*alpha;
  const padding = 20;
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto';
  const w = ctx.measureText(text).width + padding*2;
  const h = 56;
  roundRectPath(ctx, cx - w/2, cy - h/2, w, h, 12);
  ctx.fillStyle = color; ctx.fill();
  ctx.fillStyle = '#1a1830';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(text, cx, cy);
  ctx.restore();
}

/* ------------------ Game: Mouse & Cheese ----------------- */
const GRID = { cols: 24, rows: 16 };
function gridSize() {
  const margin = 40;
  const playW = UXW - margin*2, playH = UXH - 240;
  const cell = Math.floor(Math.min(playW/GRID.cols, playH/GRID.rows));
  const w = cell*GRID.cols, h = cell*GRID.rows;
  return { cell, x: (UXW-w)/2, y: (UXH - h)/2 + 30, w, h };
}
let game = null;
function newGame() {
  const start = { x: Math.floor(GRID.cols/2), y: Math.floor(GRID.rows/2) };
  game = {
    dir: {x:1, y:0}, nextDir:{x:1,y:0},
    speed: 7, lastStep: performance.now(), cellSec: 1000/7,
    segments: [start, {x:start.x-1,y:start.y}],
    cheese: randEmptyCell([start,{x:start.x-1,y:start.y}]),
    alive: true, score: 0,
    usedWordIdx: new Set(), overlayWord: null, overlayWordT: 0
  };
}
function randEmptyCell(occupied) {
  while (true) {
    const p = { x: Math.floor(Math.random()*GRID.cols), y: Math.floor(Math.random()*GRID.rows) };
    if (!occupied.some(s=>s.x===p.x&&s.y===p.y)) return p;
  }
}
function drawGame(t) {
  skyline.drawBackdrop(t);
  ui.reset();
  drawHeader('Mouse & Cheese', 'Arrow keys to move. Eat cheese, learn words!', t);

  const gs = gridSize();
  // Board frame
  ctx.save();
  roundRectPath(ctx, gs.x-8, gs.y-8, gs.w+16, gs.h+16, 18);
  ctx.fillStyle = '#1a1932'; ctx.fill();

  // Checkerboard
  for (let r=0;r<GRID.rows;r++) {
    for (let c=0;c<GRID.cols;c++) {
      const x = gs.x + c*gs.cell, y = gs.y + r*gs.cell;
      ctx.fillStyle = ((r^c)&1) ? '#262358' : '#232045';
      ctx.fillRect(x, y, gs.cell, gs.cell);
    }
  }

  // Cheese
  drawCheese(gs, game.cheese.x, game.cheese.y);

  // Mouse
  for (let i=game.segments.length-1;i>=0;i--) {
    const s = game.segments[i];
    const x = gs.x + s.x*gs.cell, y = gs.y + s.y*gs.cell;
    if (i===0) drawMouseHead(x, y, gs.cell, game.dir);
    else drawMouseBody(x, y, gs.cell, i);
  }
  ctx.restore();

  ctx.fillStyle = '#FFD166';
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'left';
  ctx.fillText(`Cheese: ${game.score}`, gs.x, gs.y-16);

  if (!game.alive) {
    drawToast(UXW*0.5, gs.y+gs.h/2, 'Oops! Tap to restart', '#EF476F', 1);
    const clickRect = { x: gs.x-20, y: gs.y-20, w: gs.w+40, h: gs.h+40 };
    ui.add(clickRect, ()=>{ newGame(); });
  }

  if (game.overlayWord && t - game.overlayWordT < 2000) {
    const a = 1 - Math.min(1, (t - game.overlayWordT)/2000);
    drawToast(UXW*0.5, gs.y-48, `RÃ©pÃ©tez: ${game.overlayWord.fr} â€” ${game.overlayWord.en}`, '#06D6A0', a);
  }

  drawFooterNav();
}
function drawCheese(gs, gx, gy) {
  const x = gs.x + gx*gs.cell + gs.cell/2;
  const y = gs.y + gy*gs.cell + gs.cell/2;
  const r = gs.cell*0.35;
  ctx.save();
  ctx.translate(x,y); ctx.rotate(0.1);
  ctx.fillStyle = '#FFD166';
  ctx.beginPath(); ctx.moveTo(-r, r*0.6); ctx.lineTo(r, 0); ctx.lineTo(-r, -r*0.6); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#E3B54A';
  for (let i=0;i<3;i++) { ctx.beginPath(); ctx.arc((Math.random()*2-1)*r*0.4, (Math.random()*2-1)*r*0.3, gs.cell*0.06 + (i%2)*2, 0, Math.PI*2); ctx.fill(); }
  ctx.restore();
}
function drawMouseHead(x, y, size, dir) {
  ctx.save();
  ctx.translate(x+size/2, y+size/2);
  const ang = dir.x===1?0 : dir.x===-1?Math.PI : dir.y===1?Math.PI/2 : -Math.PI/2;
  ctx.rotate(ang);
  ctx.fillStyle = '#C9CAD9';
  ctx.beginPath(); ctx.ellipse(0,0,size*0.42,size*0.34,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#DADAE6';
  ctx.beginPath(); ctx.arc(-size*0.22, -size*0.22, size*0.14, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(-size*0.02, -size*0.25, size*0.12, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#EF476F';
  ctx.beginPath(); ctx.arc(size*0.35, 0, size*0.06, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#2D2A3E';
  ctx.beginPath(); ctx.arc(size*0.12, -size*0.12, size*0.05, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#2D2A3E'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(size*0.2, size*0.06); ctx.lineTo(size*0.4, size*0.14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(size*0.2, -size*0.02); ctx.lineTo(size*0.4, -size*0.06); ctx.stroke();
  ctx.restore();
}
function drawMouseBody(x,y,size,i) {
  ctx.save();
  ctx.translate(x+size/2, y+size/2);
  ctx.fillStyle = i%2? '#BDBED0' : '#C9CAD9';
  ctx.beginPath(); ctx.ellipse(0,0,size*0.38,size*0.3,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function stepGame(now) {
  if (!game || !game.alive) return;
  if (now - game.lastStep < game.cellSec) return;
  game.lastStep = now;

  if ((game.nextDir.x !== -game.dir.x) || (game.nextDir.y !== -game.dir.y)) game.dir = game.nextDir;

  const head = game.segments[0];
  const nx = head.x + game.dir.x, ny = head.y + game.dir.y;

  if (nx<0 || ny<0 || nx>=GRID.cols || ny>=GRID.rows || game.segments.some(s=>s.x===nx && s.y===ny)) {
    game.alive = false; beep(180, 0.2); return;
  }

  game.segments.unshift({x:nx, y:ny});
  if (nx===game.cheese.x && ny===game.cheese.y) {
    game.score++; bump('cheese',1);
    const gs = gridSize();
    spawnConfetti((nx+0.5)*gs.cell + gs.x, (ny+0.5)*gs.cell + gs.y, 16);
    beep(900, 0.06);

    const idx = pickUnusedWord(game.usedWordIdx);
    const w = WORDS[idx];
    game.overlayWord = w; game.overlayWordT = now;
    speakWord(w.fr, w.en);

    game.cheese = randEmptyCell(game.segments);
    game.speed = Math.min(14, game.speed + 0.2);
    game.cellSec = 1000 / game.speed;
  } else {
    game.segments.pop();
  }
}
function pickUnusedWord(usedSet) {
  if (usedSet.size >= WORDS.length) usedSet.clear();
  let idx = Math.floor(Math.random()*WORDS.length);
  let tries=0; while (usedSet.has(idx) && tries<100) { idx = Math.floor(Math.random()*WORDS.length); tries++; }
  usedSet.add(idx); return idx;
}
window.addEventListener('keydown', (e)=>{
  if (scene !== Scenes.GAME || !game || !game.alive) return;
  const k = e.key;
  if (k==='ArrowUp') game.nextDir = {x:0,y:-1};
  else if (k==='ArrowDown') game.nextDir = {x:0,y:1};
  else if (k==='ArrowLeft') game.nextDir = {x:-1,y:0};
  else if (k==='ArrowRight') game.nextDir = {x:1,y:0};
});

/* ------------------ Header / Footer ---------------------- */
function drawHeader(title, subtitle, t) {
  const x=40, y=30, w=UXW-80, h=100;
  ctx.save();
  roundRectPath(ctx, x, y, w, h, 22);
  let g = cache.gradients['hdr'];
  if (!g) {
    g = ctx.createLinearGradient(x,y,x,y+h);
    g.addColorStop(0, '#2B2A49'); g.addColorStop(1, '#24233A');
    cache.gradients['hdr'] = g;
  }
  ctx.fillStyle = g; ctx.fill();
  ctx.strokeStyle = '#3A3859'; ctx.lineWidth = 3; ctx.stroke();

  ctx.textAlign = 'left';
  ctx.fillStyle = '#FFFFFF';
  ctx.font = '800 46px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.fillText(`ðŸ‡«ðŸ‡· ${title}`, x+28, y+58);

  ctx.fillStyle = '#B8B8FF';
  ctx.font = '400 22px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.fillText(subtitle, x+28, y+90);

  const goal = 20;
  const today = progress.daily[todayKey()] || {flashcards:0, quizCorrect:0, cheese:0, wordsLearned:0};
  const done = (today.flashcards + today.quizCorrect + today.cheese + today.wordsLearned);
  const pct = Math.max(0, Math.min(1, done/goal));
  const cx = x+w-70, cy = y+h/2, r = 34;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.strokeStyle='#3B3A58'; ctx.lineWidth=10; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + Math.PI*2*pct); ctx.strokeStyle='#06D6A0'; ctx.lineWidth=10; ctx.stroke();
  ctx.fillStyle = '#FFFFFF'; ctx.font = '700 18px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'center'; ctx.fillText(`${Math.round(pct*100)}%`, cx, cy+6);
  ctx.restore();
}

function drawFooterNav() {
  const y = UXH - 86;
  const buttons = [
    {label:'Home', scene:Scenes.HOME, color:'#FFD166'},
    {label:'Flashcards', scene:Scenes.FLASH, color:'#B8B8FF'},
    {label:'Quiz', scene:Scenes.QUIZ, color:'#B8F1F0'},
    {label:'Mouse & Cheese', scene:Scenes.GAME, color:'#06D6A0'},
    {label:'Progress', scene:Scenes.PROGRESS, color:'#EF476F'}
  ];
  const gap = 16;
  const bw = (UXW - 80 - gap*(buttons.length-1)) / buttons.length;
  const x0 = 40;
  for (let i=0;i<buttons.length;i++) {
    const b = buttons[i];
    const rect = drawButton(x0 + i*(bw+gap), y, bw, 56, b.label, { color: b.color });
    ui.add(rect, ()=>{
      if (b.scene === Scenes.GAME && (!game || !game.alive)) newGame();
      scene = b.scene;
      if (scene===Scenes.GAME && !game) newGame();
    });
  }
}

/* ------------------ Home & Progress ---------------------- */
function drawHome(t) {
  skyline.drawBackdrop(t);
  ui.reset();
  drawHeader('Bonjour! â€” Your French Lab', 'Pick an activity and earn your daily streak', t);

  const bFlash = drawButton(UXW*0.5-280, UXH*0.38, 560, 68, 'ðŸ“š Start Flashcards', {color:'#B8B8FF'});
  const bQuiz  = drawButton(UXW*0.5-280, UXH*0.38+90, 560, 68, 'ðŸ“ Quick Quiz', {color:'#B8F1F0'});
  const bGame  = drawButton(UXW*0.5-280, UXH*0.38+180,560, 68, 'ðŸ§€ Mouse & Cheese (Snake)', {color:'#06D6A0'});
  ui.add(bFlash, ()=>{ scene=Scenes.FLASH; });
  ui.add(bQuiz,  ()=>{ scene=Scenes.QUIZ; });
  ui.add(bGame,  ()=>{ if (!game) newGame(); scene=Scenes.GAME; });

  ctx.fillStyle = '#FFFFFF';
  ctx.textAlign = 'center';
  ctx.font = '400 22px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.fillText('Tap once after load to enable voice. Have fun!', UXW*0.5, UXH*0.38-40);

  drawStreak(UXW*0.5-360, UXH*0.38+280, 720, 100);
  drawFooterNav();
}

function drawStreak(x,y,w,h) {
  const data = getStreak(14);
  ctx.save();
  roundRectPath(ctx, x, y, w, h, 18);
  ctx.fillStyle = '#272646'; ctx.fill();
  ctx.strokeStyle = '#3B3A58'; ctx.lineWidth=3; ctx.stroke();

  ctx.fillStyle = '#FFFFFF';
  ctx.font = '700 22px system-ui, -apple-system, Segoe UI, Roboto';
  ctx.textAlign = 'left';
  ctx.fillText(`Streak: ${data.streak} day${data.streak===1?'':'s'}`, x+16, y+30);

  const padL = x+16, padR = x+w-16, top = y+60;
  const gap = (padR - padL) / 13;
  for (let i=0;i<data.days.length;i++) {
    const d = data.days[i];
    const cx = padL + i*gap;
    ctx.beginPath(); ctx.arc(cx, top+18, 12, 0, Math.PI*2);
    ctx.fillStyle = d.active ? '#06D6A0' : '#3B3A58'; ctx.fill();
  }
  ctx.restore();
}

function drawProgress(t) {
  skyline.drawBackdrop(t);
  ui.reset();
  drawHeader('Progress', 'Your last 14 days at a glance', t);

  drawStreak(UXW*0.5-360, UXH*0.3, 720, 100);

  const slab = { x: UXW*0.5-360, y: UXH*0.3+130, w: 720, h: 220 };
  ctx.save();
  roundRectPath(ctx, slab.x, slab.y, slab.w, slab.h, 20);
  ctx.fillStyle = '#272646'; ctx.fill();
  ctx.strokeStyle = '#3B3A58'; ctx.lineWidth=3; ctx.stroke();

  const metrics = [
    {label:'Flashcards', key:'flashcards', color:'#B8B8FF'},
    {label:'Quiz Correct', key:'quizCorrect', color:'#B8F1F0'},
    {label:'Cheese Eaten', key:'cheese', color:'#FFD166'},
    {label:'Words Learned', key:'wordsLearned', color:'#06D6A0'},
  ];
  const colW = slab.w/metrics.length;
  for (let i=0;i<metrics.length;i++) {
    const m = metrics[i];
    const valT = progress.totals[m.key] || 0;
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '600 22px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'center';
    ctx.fillText(m.label, slab.x + colW*(i+0.5), slab.y+54);

    ctx.fillStyle = m.color;
    ctx.font = '800 46px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(valT.toString(), slab.x + colW*(i+0.5), slab.y+120);
  }

  ctx.restore();
  drawFooterNav();
}

/* ------------------ Main Loop ---------------------------- */
function frame(t) {
  doResize(); // keep crisp on rotate/zoom

  switch (scene) {
    case Scenes.HOME:     drawHome(t); break;
    case Scenes.FLASH:    drawFlashcards(t); break;
    case Scenes.QUIZ:     drawQuiz(t); break;
    case Scenes.GAME:     stepGame(t); drawGame(t); break;
    case Scenes.PROGRESS: drawProgress(t); break;
  }
  stepConfetti(); drawConfetti();
  ui.handlePointer();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* ------------------ Init -------------------------------- */
scene = Scenes.HOME;
newGame();
canvas.tabIndex = 0; canvas.focus();

</script>
</body>
</html>
